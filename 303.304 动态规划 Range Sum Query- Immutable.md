

# 303
## Description 

Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

## Example
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1  
sumRange(2, 5) -> -1    
sumRange(0, 5) -> -3  


# 304 Insertion Sort List      
## Description    

Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

 
## Example  
Example:
Given matrix = [  
  [3, 0, 1, 4, 2],  
  [5, 6, 3, 2, 1],    
  [1, 2, 0, 1, 5],  
  [4, 1, 0, 1, 7],  
  [1, 0, 3, 0, 5]  
]

sumRegion(2, 1, 4, 3) -> 8  
sumRegion(1, 1, 2, 2) -> 11  
sumRegion(1, 2, 2, 4) -> 12 
  


## 一、动态规划
###（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

##二、基本思想与策略

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子
阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列
出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次
解决各子问题，最后一个子问题就是初始问题的解。由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是
互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求
解）。

 

三、适用的情况

能采用动态规划求解的问题的一般要具有3个性质：

    1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
	2. 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
	3. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

 

四、求解的基本步骤

(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。

(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。

**(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。**

(4)寻找边界条件

**其中第三步是最重要的。**


### Note/思路/考え方  

用动态规划来解决这两道题

在303中，要想知道 sumRange(i,j)只需要知道从0到i的sum以及从0到j的sum，二者相减即可。可以新建一个存储空间，将未来可能用到的子状态都存储在那里，需要的时候再拿来用即可。

如[1,2,3,4,5] 将会被存储成 [1,3,6,10,15]

而在304中，问题将会稍微复杂一些，我们存储的将会变成二维的数组，每一个位置（i,j）都表示从（0,0）到（i.j）的所有的数字的和。如:[  
[1,2,3],  
[4,5,6],  
[7,8,9]  
]  
将会被存储为[  
[0, 0, 0, 0],  
[0, 1, 3, 6],  
[0, 5,12,21],  
[0,12,27,45]   
]

此时如果给定的row1 = 1,col1 = 1,row 2 = 2, col2 = 2,则对应的是:
[  
[1, 2,3],  
[4, **5**,**6**],   
[7, **8**,**9**]  
] 

在我们存储的二维数组中，这四个数的和sum= 45(所有数字的和)-12（1,4,7的和）-6（1,2,3 的和）+1（被重复减掉的部分）

即 sum(row1, col1, row2, col2)=sumMatrix[row2+][col2+1] - sumMatrix[row2+1][col1]-sumMatrix[row1][col2+1]+sumMatrix[row1][col1]  

代码如下：

###303：
	class NumArray {
	    int[] accum;
	    public NumArray(int[] nums) {
	        accum = new int[nums.length+1];
	        accum[0] = 0;
	        for (int i = 1; i < accum.length; i++) {
	            accum[i] = accum[i-1] + nums[i-1];
	        }
	    }
	    
	    public int sumRange(int i, int j) {
	        return accum[j+1]-accum[i];
	    }
	}

	/**
	 * Your NumArray object will be instantiated and called as such:
	 * NumArray obj = new NumArray(nums);
	 * int param_1 = obj.sumRange(i,j);
	 */


## 304：
	class NumMatrix {
	    int[][] accum;
	    public NumMatrix(int[][] matrix) {
	        if(matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0){
	            return;
	        }
	        int m = matrix.length+1;
	        int n = matrix[0].length+1;
	        
	        accum = new int [m][n];
	        for(int i = 0; i < m; i++)  accum[i][0] = 0;
	        for(int j = 0; j < n; j++)  accum[0][j] = 0;
	        
	        for(int i = 1; i< m; i++){
				//每次存储新的一行时，sum这个变量都要归零  
	            int sum = 0;
	            for(int j = 1; j < n; j++){
					//sum存储的是原数组中当前行从0到j这几个数的和
	                sum += matrix[i-1][j-1];
					//accum数组中相应的位置的数=sum+这个数正上方的数字的
	                accum[i][j] = sum + accum[i-1][j];
	            }
	        }
	        
	    }
	    
	    public int sumRegion(int row1, int col1, int row2, int col2) {
	        if(accum == null){
	            return 0;
	        }
	        return accum[row2+1][col2+1]-accum[row2+1][col1]-accum[row1][col2+1]+accum[row1][col1];
	    }
	}

	/**
	 * Your NumMatrix object will be instantiated and called as such:
	 * NumMatrix obj = new NumMatrix(matrix);
	 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
	 */
