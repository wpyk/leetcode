# 233. Number of Digit One

## Description

Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

## Example

Input: 13
Output: 6 
Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.

## 思路

这道题的思路说起来很费劲，网上搜到的答案也很难理解。  
按照我的思路理解，其实就是从个位开始计算1出现的个数。各位计算完了之后，n/=10，将十位放在个位的位置，再算十位上1出现的个数，一直循环。  
当计算个位上的1的个数的时候，首先要计算各位出现了几轮。每一轮指的是个位按顺序经历[0,9]上的每一个数；因此a的初始值是1，有多少轮，就多少个1。 但是如果只是简答的n/10判断轮数的话，会出现差错，比如50/10,5个，51/10还是5个，但是显然51比50多一个1。如果是52~69，其实结果是相同的。因此可以通过（x+8）/10来包含更多的情况。只要个位是>2的，（x+8）/10就会比x/10大。 同时，b是用来看个位是否刚好为1， 如果是的话，就添上。

当计算完个位之后，去计算十位上的1的时候，假如说给的数字是n=113，那经历过第一轮后n会变成11，此时我们考虑，从0到113的所有数字中，后两位是[10,11,12,13,14,15,16,17,18,19]会出现几轮，轮数乘以10就是多出的1。多少轮还是按照上面的方法，只是这次a=10了，每一轮有10个1。b是用来算110-113之间在十位上有多少个1的。

最不好理解的其实是b，可以参照图中的几个路线。其实能用到b的时候，都是当前的n%10 ==1的时候，此时前半部分（x+8）/10*a计算的都是完整的一轮一轮的，而没有形成完整的轮的零散的1需要通过b来计算。那b就指的是没有形成完整轮中的1的个数。

题目解释起来很抽象，最重要的就是记住题目的运行逻辑是从个位开始寻找所有的1.

## 代码

	class Solution {
	    public int countDigitOne(int n) {
	        int result = 0;
	        //
	        int a = 1;
	        //
	        int b = 1;
	        
	        while(n>0){
	            result += (n+8)/10*a+(n%10 == 1? (n%10)*b:0);
	            b += (n%10)*a;
	            a *= 10;
	            n /= 10;
	        }
	        
	        return result;
	    }
	}